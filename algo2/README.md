# R-Treeに関する考察

## 1. 検索における効果

R-tree（Guttman, 1984）は，**空間検索（spatial searching）において高い効率性を発揮する動的インデックス構造**である．特に，CADデータや地理情報（GIS）などのように，オブジェクトが多次元空間上で非ゼロの面積や体積を持つ場合に適している．

B木など従来の一次元インデックス構造では，キー値を線形にソートして格納するため，**多次元空間での範囲検索や重なり検索を効果的に処理できない**という問題があった．  
一方，R-treeはオブジェクトを**n次元の最小外接矩形（Minimum Bounding Rectangle, MBR）**で表し，ノード間でこれらの矩形を階層的に包含させることで，空間内の領域検索を効率化する．

検索処理においては，指定した検索領域と重なるノードだけを辿るため，全探索を行う必要がなく，**探索空間を大幅に削減できる**．また，ノード分割の際には矩形の重なりが最小となるように分割されるため，不要な領域アクセスを低減する．

結果として，R-treeは以下のような検索性能上の効果を持つ：
- 範囲検索・近傍検索（range / overlap query）の高速化  
- 多次元空間（2D, 3Dなど）における効率的な探索  
- 動的更新（挿入・削除）を伴う環境でも再構築不要で高性能を維持  

これにより，空間データを扱うシステムにおいて**CPU負荷およびディスクI/Oコストを削減**し，リアルタイム性を必要とする空間検索処理に有効であることが実験的に示されている．

---

## 2. 一般的な木構造（例：B木）との違い

| 比較項目 | R-tree | B-tree（一般的な木構造） |
|-----------|---------|-----------------------------|
| **対象データ** | 空間データ（矩形・領域・多次元） | 一次元データ（数値・文字列など） |
| **キー構造** | n次元の最小外接矩形（MBR） | 単一のスカラーキー（昇順に整列） |
| **ノード内容** | `(矩形, 子ノードポインタ)` または `(矩形, オブジェクトID)` | `(キー, 子ノードポインタ)` または `(キー, 値)` |
| **検索条件** | 範囲検索・重なり検索・包含検索など | 完全一致検索・範囲検索（一次元） |
| **空間分割の考え方** | 領域を矩形で分割し，重なりを最小化 | キー値を昇順で分割（重複なし） |
| **重なり** | ノード矩形間に重なりが存在する | 範囲は常に互いに非重複 |
| **適用分野** | 地理情報システム（GIS），CAD，VLSI設計，画像検索 | 一般的なRDBMSインデックス，ファイルシステムなど |

R-treeは**空間的な包含関係（containment relationship）**を基盤に設計されており，**重なりのある多次元領域を効率的に管理**できる点がB-treeやK-D-B treeなどと根本的に異なる．  
また，B-treeでは隣接ノード間に明確な順序関係があるのに対し，R-treeでは矩形の重なりにより**探索パスが複数分岐する可能性**がある点も特徴的である．

---

## 3. 計算量の比較

| 操作 | R-tree | B-tree | 備考 |
|------|--------------------|-------------------|------|
| **探索（Search）** | O(logₘN) ～ O(N<sup>1−1/d</sup>) | O(logₘN) | R-treeでは空間の次元数 d に依存．次元が高いほど重なりが増えやすく，探索コストが増加． |
| **挿入（Insert）** | O(logₘN) | O(logₘN) | 分割処理（SplitNode）発生時に若干のオーバーヘッドあり． |
| **削除（Delete）** | O(logₘN) | O(logₘN) | CondenseTree操作により，再挿入が必要な場合がある． |
| **更新（Update）** | O(logₘN) + O(k) | O(logₘN) | R-treeでは位置変更時に削除＋挿入が発生． |
| **空間使用効率** | 約70〜90%（ノード充填率） | 約50〜100% | R-treeは重なりを最小化する設計により比較的高い空間利用率を維持． |

> ※ N：データ件数，m：ノードの最小エントリ数，d：次元数（2Dや3Dなど）

R-treeは平均的にはB-treeと同程度の計算量で動作するが，空間次元が増えると重なりが増加し，探索性能が低下する（**次元の呪い**）という特徴がある．  
そのため，実装時には**線形分割アルゴリズムやHilbert R-tree**などの改良版が利用されることが多い．

---

### 参考
> Antonin Guttman, “R-trees: A Dynamic Index Structure for Spatial Searching”, *Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data*, pp.47–57, 1984．

---

<img width="1023" height="435" alt="image" src="https://github.com/user-attachments/assets/aeffdb77-bf07-436f-85bf-054323dc463b" />

---

## 4. 基本操作の流れ

### 4.1 挿入（Insertion）

挿入操作は，B木の挿入に類似しているが，「矩形の重なり最小化」を考慮する点が特徴である．  
手順は以下の通り：

1. **挿入先ノードの選択（ChooseLeaf）**  
   - ルートから探索を開始し，新しいオブジェクトを挿入する葉ノードを選択する．  
   - 各階層で，MBRを最小限に拡張する必要があるノードを選ぶ（重なり最小化）．

2. **挿入とノード分割（SplitNode）**  
   - 葉ノードに空きがあれば，そのまま挿入．  
   - 容量オーバー（最大Mを超える）場合は，ノードを2つに分割し，それぞれのMBRを再計算する．  
   - 分割アルゴリズムには線形（Linear），二次（Quadratic）などの方式がある．

3. **上位ノードの更新（AdjustTree）**  
   - 分割結果を親ノードに反映し，MBRを再調整．  
   - 必要に応じて上位ノードも分割を繰り返す．

4. **ルート分割**  
   - ルートまで分割が波及した場合は，新たなルートを作成してツリーを1段高くする．

<img width="1024" height="747" alt="image" src="https://github.com/user-attachments/assets/b08e63da-993b-47fc-8f4f-17a68349c1cf" />

---

### 4.2 検索（Search）

検索は，指定した領域と重なるMBRをたどることで行う．

1. ルートから探索を開始し，検索矩形と重なるMBRを持つノードだけを再帰的に探索する．  
2. 葉ノードに到達したら，対象矩形と重なる実データを抽出する．

<img width="1024" height="747" alt="image" src="https://github.com/user-attachments/assets/96974e9f-6a5b-41bb-bcb9-19a97a640152" />

---

### 4.3 削除（Deletion）

削除は，対象オブジェクトを含むノードを探し出して削除し，必要に応じて再調整を行う．

1. **対象ノードの探索（FindLeaf）**  
   - 削除対象のMBRを含む葉ノードを探索．

2. **削除とノード再構成（CondenseTree）**  
   - 削除によりノード内のエントリ数が最小値mを下回った場合，そのノードを削除し，  
     その子要素を再挿入（re-insertion）する．
   - これにより，ツリー構造が自然に再最適化される．

3. **ルート調整**  
   - ルートに子ノードが1つしか残らなければ，その子を新しいルートとする．

---

## 5. まとめ

R-treeは，  
- **多次元データ（点・線・面）**を効率的に管理し，  
- **挿入・削除・探索が動的に可能な高さ平衡木**であり，  
- **矩形の重なりを最小化するアルゴリズム設計**により高い空間検索性能を実現する．  

また，B-treeなどの一次元構造と比較しても，平均計算量はほぼ同等でありながら，  
**空間的データの処理能力に優れる**点で実用的価値が高い．
